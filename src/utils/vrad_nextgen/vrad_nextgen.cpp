#include "tier0/dbg.h"
#include "tier0/icommandline.h"
#include <algorithm>
#include <iostream>
#include <vector>

// Math and Core Types
#include "mathlib/mathlib.h"

// Command Line and File Utilities
#include "cmdlib.h"
#include "pacifier.h"
#include "threads.h"
#include "tier1/strtools.h"

// BSP Data parsing
#include "bsplib.h"

// KeyValues for VMT parsing
#include "KeyValues.h"

// VTF header structures and ImageLoader for DXT decompression
#include "bitmap/imageformat.h"
#include "vtf/vtf.h"

// CUDA + OptiX
#include <cuda.h>
#include <cuda_runtime.h>
#include <optix.h>
#include <optix_function_table_definition.h>
#include <optix_stubs.h>

// Embedded PTX (generated by compile_ptx.bat)
#include "optix_kernels_ptx.h"

// Globals needed by bsplib
CUtlVector<dworldlight_t> g_pWorldLights;

// Dynamic loader for filesystem_stdio.dll
#include "tier1/interface.h"
#ifdef _WIN32
#include <windows.h>
#endif

// -------------------------------------------------------------
// Dummy Stubs for CmdLib and BspLib dependencies
// -------------------------------------------------------------
char qdir[1024] = "";
bool g_bUseDefaultBoundingBox = true;

class IBaseFileSystem;
IFileSystem *g_pFullFileSystem = nullptr;
IBaseFileSystem *g_pFileSystem = nullptr;

bool FileSystem_Init(char const *, int, FSInitType_t, bool) {
  CSysModule *pModule = Sys_LoadModule("filesystem_stdio");
  if (!pModule) {
    Warning("vrad_nextgen: Failed to load filesystem_stdio.dll\n");
    return false;
  }
  CreateInterfaceFn factory = Sys_GetFactory(pModule);
  if (!factory) {
    Warning("vrad_nextgen: Failed to get factory\n");
    return false;
  }
  g_pFullFileSystem =
      (IFileSystem *)factory(FILESYSTEM_INTERFACE_VERSION, NULL);
  g_pFileSystem = (IBaseFileSystem *)g_pFullFileSystem;
  if (!g_pFileSystem) {
    Warning("vrad_nextgen: Failed to create IFileSystem\n");
    return false;
  }
  return true;
}

void FileSystem_Term() {}
CreateInterfaceFn FileSystem_GetFactory() { return nullptr; }

unsigned char *LZMA_Compress(unsigned char *pInput, unsigned int inputSize,
                             unsigned int *pOutputSize) {
  return nullptr;
}
void GenerateLumpFileName(char const *pMapName, char *pLumpFileName,
                          int nMaxLumpFileNameLength, int nLumpId) {}

// -------------------------------------------------------------
// VTF File Reading and Decompression
// Uses IFileSystem::Open/Read/Close for safe memory management
// and ImageLoader::ConvertImageFormat for DXT decompression
// (both from bitmap.lib, statically linked, no cross-DLL issues)
// -------------------------------------------------------------

struct VTFLoadResult {
  bool valid;
  int width;
  int height;
  int mipCount;
  ImageFormat srcFormat;
  std::vector<unsigned char> rgbaPixels; // mip 0, RGBA8888
};

// Compute the byte size of a single mip level for the given format
static int ComputeMipSize(int width, int height, ImageFormat fmt) {
  return ImageLoader::GetMemRequired(width, height, 1, fmt, false);
}

// Compute the total byte offset to the start of the highest-resolution mip
// VTF stores mips from smallest to largest, so we need to skip past all
// the smaller mip levels to reach mip 0.
static int ComputeMip0Offset(int width, int height, int numMips, int numFrames,
                             int numFaces, ImageFormat fmt) {
  int offset = 0;
  for (int mip = numMips - 1; mip > 0; mip--) {
    int mipW = width >> mip;
    int mipH = height >> mip;
    if (mipW < 1)
      mipW = 1;
    if (mipH < 1)
      mipH = 1;
    int mipSize = ComputeMipSize(mipW, mipH, fmt);
    offset += mipSize * numFrames * numFaces;
  }
  return offset;
}

static VTFLoadResult LoadVTFFromFile(IFileSystem *pFS, const char *vtfPath) {
  VTFLoadResult result = {};
  result.valid = false;

  // Open and read the entire file
  FileHandle_t fh = pFS->Open(vtfPath, "rb", "GAME");
  if (!fh)
    return result;

  int fileSize = pFS->Size(fh);
  if (fileSize < (int)sizeof(VTFFileHeaderV7_1_t)) {
    pFS->Close(fh);
    return result;
  }

  std::vector<unsigned char> fileData(fileSize);
  int bytesRead = pFS->Read(fileData.data(), fileSize, fh);
  pFS->Close(fh);

  if (bytesRead != fileSize)
    return result;

  // Validate VTF magic
  const VTFFileBaseHeader_t *pBase =
      (const VTFFileBaseHeader_t *)fileData.data();
  if (memcmp(pBase->fileTypeString, "VTF\0", 4) != 0)
    return result;

  int majorVer = pBase->version[0];
  int minorVer = pBase->version[1];
  int headerSize = pBase->headerSize;

  // Parse the v7.1 header (common baseline for all VTF versions)
  const VTFFileHeaderV7_1_t *pHdr =
      (const VTFFileHeaderV7_1_t *)fileData.data();
  result.width = pHdr->width;
  result.height = pHdr->height;
  result.mipCount = pHdr->numMipLevels;
  result.srcFormat = pHdr->imageFormat;

  int numFrames = pHdr->numFrames;
  if (numFrames < 1)
    numFrames = 1;

  // Determine number of faces (cubemaps have 6-7 faces)
  int numFaces = 1;
  if (pHdr->flags & TEXTUREFLAGS_ENVMAP)
    numFaces = (majorVer >= 7 && minorVer >= 1) ? 7 : 6;

  // Low-res image size (thumbnail stored before the actual image data)
  int lowResSize = 0;
  if (pHdr->lowResImageFormat != IMAGE_FORMAT_UNKNOWN) {
    lowResSize = ComputeMipSize(pHdr->lowResImageWidth, pHdr->lowResImageHeight,
                                pHdr->lowResImageFormat);
  }

  // For v7.3+, headerSize accounts for the resource entries.
  // For v7.1-7.2, data starts right after the header struct.
  int dataStart = headerSize;

  // For versions < 7.3, add padding for the VectorAligned in the struct
  if (majorVer == 7 && minorVer < 3) {
    // The actual struct size can be larger due to VectorAligned padding
    // Use the headerSize from the file which accounts for this
  }

  // Image data starts after the header and low-res image
  int imageDataStart = dataStart + lowResSize;

  // For v7.3+, we need to find the image data resource entry
  if (majorVer == 7 && minorVer >= 3) {
    // v7.3+ has resource entries after the header
    int numResources = 0;
    if (fileSize >= (int)sizeof(VTFFileHeaderV7_3_t)) {
      const VTFFileHeaderV7_3_t *p73 =
          (const VTFFileHeaderV7_3_t *)fileData.data();
      numResources = p73->numResources;
    }

    // Resource entries follow the header (after any compiler padding)
    // The actual position is at headerSize (which is set by the VTF writer)
    const unsigned char *pResources =
        fileData.data() + sizeof(VTFFileHeaderV7_3_t);

    // Account for VectorAligned padding (struct ends at 0x48 but infos
    // start at 0x50 on PC due to compiler padding)
    int paddedHeaderSize = (int)(sizeof(VTFFileHeaderV7_3_t));
    // Round up to 16-byte boundary
    paddedHeaderSize = (paddedHeaderSize + 15) & ~15;
    pResources = fileData.data() + paddedHeaderSize;

    for (int r = 0; r < numResources && r < MAX_RSRC_DICTIONARY_ENTRIES; r++) {
      const ResourceEntryInfo *pEntry =
          (const ResourceEntryInfo *)(pResources +
                                      r * sizeof(ResourceEntryInfo));
      if ((int)(pResources + (r + 1) * sizeof(ResourceEntryInfo) -
                fileData.data()) > fileSize)
        break;

      if (pEntry->eType == VTF_LEGACY_RSRC_IMAGE) {
        imageDataStart = pEntry->resData;
      } else if (pEntry->eType == VTF_LEGACY_RSRC_LOW_RES_IMAGE) {
        // Low-res image resource, skip it
      }
    }
  }

  // Compute offset from imageDataStart to the mip 0 data
  int mip0Offset =
      ComputeMip0Offset(result.width, result.height, result.mipCount, numFrames,
                        numFaces, result.srcFormat);

  int mip0Start = imageDataStart + mip0Offset;
  int mip0Size = ComputeMipSize(result.width, result.height, result.srcFormat);

  if (mip0Start + mip0Size > fileSize) {
    // File is truncated
    return result;
  }

  // Decompress / convert to RGBA8888
  int rgbaSize = ImageLoader::GetMemRequired(result.width, result.height, 1,
                                             IMAGE_FORMAT_RGBA8888, false);
  result.rgbaPixels.resize(rgbaSize);

  const unsigned char *srcData = fileData.data() + mip0Start;

  if (result.srcFormat == IMAGE_FORMAT_RGBA8888) {
    // Already in target format, just copy
    memcpy(result.rgbaPixels.data(), srcData, rgbaSize);
  } else {
    // Use ImageLoader to convert (handles DXT1, DXT3, DXT5, BGR888, etc.)
    bool ok = ImageLoader::ConvertImageFormat(
        srcData, result.srcFormat, result.rgbaPixels.data(),
        IMAGE_FORMAT_RGBA8888, result.width, result.height);
    if (!ok) {
      result.rgbaPixels.clear();
      return result;
    }
  }

  result.valid = true;
  return result;
}

static const char *ImageFormatName(ImageFormat fmt) {
  switch (fmt) {
  case IMAGE_FORMAT_DXT1:
    return "DXT1";
  case IMAGE_FORMAT_DXT3:
    return "DXT3";
  case IMAGE_FORMAT_DXT5:
    return "DXT5";
  case IMAGE_FORMAT_RGBA8888:
    return "RGBA8888";
  case IMAGE_FORMAT_BGRA8888:
    return "BGRA8888";
  case IMAGE_FORMAT_RGB888:
    return "RGB888";
  case IMAGE_FORMAT_BGR888:
    return "BGR888";
  case IMAGE_FORMAT_ABGR8888:
    return "ABGR8888";
  case IMAGE_FORMAT_BGRX8888:
    return "BGRX8888";
  case IMAGE_FORMAT_BGR565:
    return "BGR565";
  case IMAGE_FORMAT_I8:
    return "I8";
  case IMAGE_FORMAT_IA88:
    return "IA88";
  case IMAGE_FORMAT_UV88:
    return "UV88";
  default:
    return "unknown";
  }
}

// -------------------------------------------------------------
// Parsed material properties
// -------------------------------------------------------------
struct MaterialInfo {
  const char *name;
  char shaderName[128];
  char baseTexture[256];
  char bumpMap[256];
  bool translucent;
  bool alphaTest;
  bool selfIllum;
  Vector reflectivity;

  // VTF decoded data
  int vtfWidth;
  int vtfHeight;
  ImageFormat vtfSrcFormat;
  int vtfMips;
  bool vtfLoaded;
  std::vector<unsigned char> vtfPixels; // RGBA8888 mip 0
};

int main(int argc, char *argv[]) {
  CommandLine()->CreateCmdLine(argc, argv);
  MathLib_Init(2.2f, 2.2f, 0.0f, 2.0f);

  std::cout << "=====================================\n";
  std::cout << " vrad_nextgen: Modern RTX Lightmapper \n";
  std::cout << "=====================================\n";

  if (argc < 2) {
    std::cerr << "Usage: vrad_nextgen <map.bsp>\n";
    return 1;
  }

  CmdLib_InitFileSystem(argv[argc - 1], 0);

  char sourcePath[1024];
  Q_strncpy(sourcePath, argv[argc - 1], sizeof(sourcePath));
  Q_DefaultExtension(sourcePath, ".bsp", sizeof(sourcePath));

  char bspDir[1024];
  Q_strncpy(bspDir, sourcePath, sizeof(bspDir));
  Q_StripFilename(bspDir);
  if (g_pFullFileSystem && bspDir[0]) {
    g_pFullFileSystem->AddSearchPath(bspDir, "GAME");
    g_pFullFileSystem->AddSearchPath(bspDir, "DEFAULT_WRITE_PATH");

    const char *pGameDir = CommandLine()->ParmValue("-game");
    char resolvedGameDir[1024] = "";
    if (pGameDir) {
      Q_MakeAbsolutePath(resolvedGameDir, sizeof(resolvedGameDir), pGameDir);
      g_pFullFileSystem->AddSearchPath(resolvedGameDir, "GAME");
      std::cout << "  Game content root (-game): " << resolvedGameDir << "\n";
    } else {
      Q_strncpy(resolvedGameDir, bspDir, sizeof(resolvedGameDir));
      Q_StripTrailingSlash(resolvedGameDir);
      Q_StripFilename(resolvedGameDir);
      if (resolvedGameDir[0]) {
        g_pFullFileSystem->AddSearchPath(resolvedGameDir, "GAME");
        std::cout << "  Game content root (auto): " << resolvedGameDir << "\n";
      }
    }

    if (resolvedGameDir[0]) {
      char vpkSearch[1024];
      Q_snprintf(vpkSearch, sizeof(vpkSearch), "%s/*_dir.vpk", resolvedGameDir);
      FileFindHandle_t findHandle;
      const char *pVPKName =
          g_pFullFileSystem->FindFirstEx(vpkSearch, NULL, &findHandle);
      while (pVPKName) {
        char vpkFullPath[1024];
        Q_snprintf(vpkFullPath, sizeof(vpkFullPath), "%s/%s", resolvedGameDir,
                   pVPKName);
        g_pFullFileSystem->AddSearchPath(vpkFullPath, "GAME");
        std::cout << "  Mounted VPK: " << pVPKName << "\n";
        pVPKName = g_pFullFileSystem->FindNext(findHandle);
      }
      g_pFullFileSystem->FindClose(findHandle);
    }
  }

  // =================================================================
  // Phase 1: Geometry Setup
  // =================================================================
  std::cout << "\n[ Phase 1: Geometry Setup ]\n";
  std::cout << "Loading: " << sourcePath << "\n";
  LoadBSPFile(sourcePath);
  ParseEntities();
  std::cout << "[ Phase 1: Summary ]\n";
  std::cout << "  Faces=" << numfaces << " Brushes=" << numbrushes
            << " Entities=" << num_entities << " TexData=" << numtexdata
            << "\n";

  // =================================================================
  // Phase 2: Material Extraction & VMT Parsing
  // =================================================================
  std::cout << "\n[ Phase 2: Material Extraction & VMT Parsing ]\n";
  std::vector<MaterialInfo> materials(numtexdata);
  int vmtFound = 0, vmtMissing = 0;
  for (int i = 0; i < numtexdata; i++) {
    MaterialInfo &mat = materials[i];
    mat.name = TexDataStringTable_GetString(dtexdata[i].nameStringTableID);
    mat.reflectivity = dtexdata[i].reflectivity;
    mat.shaderName[0] = '\0';
    mat.baseTexture[0] = '\0';
    mat.bumpMap[0] = '\0';
    mat.translucent = false;
    mat.alphaTest = false;
    mat.selfIllum = false;
    mat.vtfWidth = 0;
    mat.vtfHeight = 0;
    mat.vtfSrcFormat = IMAGE_FORMAT_UNKNOWN;
    mat.vtfMips = 0;
    mat.vtfLoaded = false;

    char vmtPath[512];
    Q_snprintf(vmtPath, sizeof(vmtPath), "materials/%s.vmt", mat.name);
    KeyValues *pVMT = new KeyValues("VMT");
    if (pVMT->LoadFromFile(g_pFileSystem, vmtPath, "GAME")) {
      vmtFound++;
      Q_strncpy(mat.shaderName, pVMT->GetName(), sizeof(mat.shaderName));
      const char *bt = pVMT->GetString("$basetexture", "");
      if (bt[0])
        Q_strncpy(mat.baseTexture, bt, sizeof(mat.baseTexture));
      const char *bm = pVMT->GetString("$bumpmap", "");
      if (bm[0])
        Q_strncpy(mat.bumpMap, bm, sizeof(mat.bumpMap));
      mat.translucent = pVMT->GetInt("$translucent", 0) != 0;
      mat.alphaTest = pVMT->GetInt("$alphatest", 0) != 0;
      mat.selfIllum = pVMT->GetInt("$selfillum", 0) != 0;
    } else {
      vmtMissing++;
    }
    pVMT->deleteThis();

    std::cout << "  [" << i << "] " << mat.name;
    if (mat.shaderName[0])
      std::cout << " -> " << mat.shaderName;
    if (mat.baseTexture[0])
      std::cout << " | tex=" << mat.baseTexture;
    std::cout << "\n";
  }
  std::cout << "  VMTs: " << vmtFound << " found, " << vmtMissing
            << " missing\n";

  // =================================================================
  // Phase 3: VTF Texture Loading & Decompression
  // Reads each VTF file, parses the header manually, and decompresses
  // the mip 0 pixel data from DXT/BGR/etc to RGBA8888 using
  // ImageLoader::ConvertImageFormat (from bitmap.lib).
  // =================================================================
  std::cout << "\n[ Phase 3: VTF Texture Loading ]\n";
  int vtfLoaded = 0, vtfFailed = 0;
  int totalPixelBytes = 0;

  for (int i = 0; i < numtexdata; i++) {
    MaterialInfo &mat = materials[i];
    if (!mat.baseTexture[0])
      continue;

    char vtfPath[512];
    Q_snprintf(vtfPath, sizeof(vtfPath), "materials/%s.vtf", mat.baseTexture);

    VTFLoadResult vtf = LoadVTFFromFile(g_pFullFileSystem, vtfPath);
    if (!vtf.valid || vtf.rgbaPixels.empty()) {
      std::cout << "  [" << i << "] " << mat.baseTexture << " - FAILED\n";
      vtfFailed++;
      continue;
    }

    mat.vtfWidth = vtf.width;
    mat.vtfHeight = vtf.height;
    mat.vtfSrcFormat = vtf.srcFormat;
    mat.vtfMips = vtf.mipCount;
    mat.vtfLoaded = true;
    mat.vtfPixels = std::move(vtf.rgbaPixels);
    totalPixelBytes += (int)mat.vtfPixels.size();
    vtfLoaded++;

    // Sanity check: print first pixel RGBA values
    unsigned char r = mat.vtfPixels[0], g = mat.vtfPixels[1],
                  b = mat.vtfPixels[2], a = mat.vtfPixels[3];

    std::cout << "  [" << i << "] " << mat.baseTexture << " (" << mat.vtfWidth
              << "x" << mat.vtfHeight << " "
              << ImageFormatName(mat.vtfSrcFormat) << " -> RGBA8888, "
              << ((int)mat.vtfPixels.size() / 1024) << " KB"
              << ", pixel[0]=(" << (int)r << "," << (int)g << "," << (int)b
              << "," << (int)a << ")"
              << ")\n";
  }

  std::cout << "\n[ Phase 3: Summary ]\n";
  std::cout << "  VTFs loaded:  " << vtfLoaded << "\n";
  std::cout << "  VTFs failed:  " << vtfFailed << "\n";
  std::cout << "  Total pixels: " << (totalPixelBytes / 1024) << " KB\n";

  // =================================================================
  // Phase 4: Texture Atlas Construction
  // Packs all decoded RGBA8888 textures into a single atlas image
  // using shelf-based bin packing. Records per-material UV remapping.
  // =================================================================
  std::cout << "\n[ Phase 4: Texture Atlas Construction ]\n";

  struct AtlasEntry {
    int materialIdx;
    int srcWidth, srcHeight;
    int atlasX, atlasY;
    float uvScaleX, uvScaleY;
    float uvOffsetX, uvOffsetY;
  };

  std::vector<AtlasEntry> atlasEntries;
  for (int i = 0; i < numtexdata; i++) {
    if (!materials[i].vtfLoaded)
      continue;
    AtlasEntry e = {};
    e.materialIdx = i;
    e.srcWidth = materials[i].vtfWidth;
    e.srcHeight = materials[i].vtfHeight;
    atlasEntries.push_back(e);
  }

  // Sort by height descending for better shelf packing
  std::sort(atlasEntries.begin(), atlasEntries.end(),
            [](const AtlasEntry &a, const AtlasEntry &b) {
              return a.srcHeight > b.srcHeight;
            });

  // Shelf-based packing: try increasing atlas widths until it fits
  int atlasWidth = 1024, atlasHeight = 0;
  bool packed = false;
  while (!packed && atlasWidth <= 16384) {
    int curX = 0, curY = 0, rowH = 0;
    for (auto &e : atlasEntries) {
      if (curX + e.srcWidth > atlasWidth) {
        curY += rowH;
        curX = 0;
        rowH = 0;
      }
      e.atlasX = curX;
      e.atlasY = curY;
      curX += e.srcWidth;
      if (e.srcHeight > rowH)
        rowH = e.srcHeight;
    }
    atlasHeight = curY + rowH;
    // Round up to power-of-2
    int h = 1;
    while (h < atlasHeight)
      h <<= 1;
    atlasHeight = h;
    packed = (atlasHeight <= 16384);
    if (!packed)
      atlasWidth <<= 1;
  }

  if (!packed) {
    std::cout << "  ERROR: Textures too large to fit in 16K atlas!\n";
  } else {
    int atlasSizeBytes = atlasWidth * atlasHeight * 4;
    std::vector<unsigned char> atlasData(atlasSizeBytes, 0);

    // Blit each texture into atlas and compute UV remapping
    for (auto &e : atlasEntries) {
      const MaterialInfo &mat = materials[e.materialIdx];
      e.uvScaleX = (float)e.srcWidth / (float)atlasWidth;
      e.uvScaleY = (float)e.srcHeight / (float)atlasHeight;
      e.uvOffsetX = (float)e.atlasX / (float)atlasWidth;
      e.uvOffsetY = (float)e.atlasY / (float)atlasHeight;

      for (int y = 0; y < e.srcHeight; y++) {
        int srcOff = y * e.srcWidth * 4;
        int dstOff = ((e.atlasY + y) * atlasWidth + e.atlasX) * 4;
        memcpy(&atlasData[dstOff], &mat.vtfPixels[srcOff], e.srcWidth * 4);
      }

      std::cout << "  [" << e.materialIdx << "] " << mat.baseTexture
                << " -> atlas(" << e.atlasX << "," << e.atlasY << ") "
                << e.srcWidth << "x" << e.srcHeight << " uv=[" << e.uvOffsetX
                << "," << e.uvOffsetY << "]+"
                << "[" << e.uvScaleX << "," << e.uvScaleY << "]\n";
    }

    std::cout << "\n[ Phase 4: Summary ]\n";
    std::cout << "  Atlas size:      " << atlasWidth << "x" << atlasHeight
              << " (" << (atlasSizeBytes / 1024) << " KB)\n";
    std::cout << "  Textures packed: " << atlasEntries.size() << "\n";
    std::cout << "  Packing eff:     "
              << (totalPixelBytes * 100 / atlasSizeBytes) << "%\n";
    std::cout << "  Ready for GPU upload.\n";

    // Free per-material pixel buffers (data is now in atlas)
    for (int i = 0; i < numtexdata; i++) {
      materials[i].vtfPixels.clear();
      materials[i].vtfPixels.shrink_to_fit();
    }
  }

  // =================================================================
  // Phase 5: OptiX Direct Lighting
  // CUDA + OptiX init, BVH from BSP, shadow ray kernel launch.
  // =================================================================
  std::cout << "\n[ Phase 5: OptiX Direct Lighting ]\n";

  // Host-side structs (must match device-side in .cu)
  struct PointLight {
    float posX, posY, posZ;
    float colR, colG, colB;
    float constAttn, linearAttn, quadAttn;
  };
  struct GPUFaceInfo {
    float lmS[4]; // lightmapVecsLuxelsPerWorldUnits[0]
    float lmT[4]; // lightmapVecsLuxelsPerWorldUnits[1]
    int lmMinsS, lmMinsT;
    int lmW, lmH;
    int luxelOffset;
    float reflR, reflG, reflB;
    float normalX, normalY, normalZ;
  };
  struct LaunchParams {
    OptixTraversableHandle traversable;
    float *outputBuffer;
    int numSamples;
    float sunDirX, sunDirY, sunDirZ;
    float sunColorR, sunColorG, sunColorB;
    int hasSun;
    PointLight *lights;
    int numLights;
    float *samplePositions;
    float *sampleNormals;
    int *triToFace;
    GPUFaceInfo *faceInfos;
    float *bounceLightIn;
    int bouncePassIndex;
    int numBounceRays;
    int totalLuxels;
  };

  std::cout << "  [DEBUG] CPU LaunchParams size=" << sizeof(LaunchParams)
            << " offset bouncePass=" << offsetof(LaunchParams, bouncePassIndex)
            << " offset output=" << offsetof(LaunchParams, outputBuffer)
            << "\n";

  CUresult cuRes = cuInit(0);
  if (cuRes != CUDA_SUCCESS) {
    std::cout << "  ERROR: cuInit failed\n";
    goto phase5_done;
  }
  {
    CUdevice cuDevice;
    cuDeviceGet(&cuDevice, 0);
    char deviceName[256];
    cuDeviceGetName(deviceName, sizeof(deviceName), cuDevice);
    int smMajor, smMinor;
    cuDeviceGetAttribute(&smMajor, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR,
                         cuDevice);
    cuDeviceGetAttribute(&smMinor, CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR,
                         cuDevice);
    std::cout << "  GPU: " << deviceName << " (SM " << smMajor << "." << smMinor
              << ")\n";
    cudaSetDevice(0);
    cudaFree(0);
    CUcontext cuCtx;
    cuCtxGetCurrent(&cuCtx);

    OptixResult optRes = optixInit();
    if (optRes != OPTIX_SUCCESS) {
      std::cout << "  ERROR: optixInit\n";
      goto phase5_done;
    }
    OptixDeviceContext optixCtx = nullptr;
    OptixDeviceContextOptions ctxOpts = {};
    optRes = optixDeviceContextCreate(cuCtx, &ctxOpts, &optixCtx);
    if (optRes != OPTIX_SUCCESS) {
      std::cout << "  ERROR: context\n";
      goto phase5_done;
    }

    // --- Triangulate BSP faces ---
    struct float3_t {
      float x, y, z;
    };
    std::vector<float3_t> triVerts;
    std::vector<int> triToFace; // triangle index → face index
    for (int fi = 0; fi < numfaces; fi++) {
      dface_t &f = dfaces[fi];
      if (f.numedges < 3)
        continue;
      std::vector<float3_t> pv(f.numedges);
      for (int j = 0; j < f.numedges; j++) {
        int se = dsurfedges[f.firstedge + j];
        int vi = (se < 0) ? dedges[-se].v[1] : dedges[se].v[0];
        pv[j] = {dvertexes[vi].point[0], dvertexes[vi].point[1],
                 dvertexes[vi].point[2]};
      }
      for (int j = 1; j < f.numedges - 1; j++) {
        triVerts.push_back(pv[0]);
        triVerts.push_back(pv[j]);
        triVerts.push_back(pv[j + 1]);
        triToFace.push_back(fi); // map this triangle → face index
      }
    }
    int numTris = (int)triVerts.size() / 3;
    std::cout << "  " << numTris << " triangles from " << numfaces
              << " faces\n";
    if (triVerts.size() >= 3) {
      std::cout << "  Sample Triangle 0: (" << triVerts[0].x << ","
                << triVerts[0].y << "," << triVerts[0].z << "), "
                << "(" << triVerts[1].x << "," << triVerts[1].y << ","
                << triVerts[1].z << "), "
                << "(" << triVerts[2].x << "," << triVerts[2].y << ","
                << triVerts[2].z << ")\n";
    }

    // --- Upload + BVH ---
    CUdeviceptr d_vertices = 0;
    cudaMalloc(reinterpret_cast<void **>(&d_vertices),
               triVerts.size() * sizeof(float3_t));
    cudaMemcpy(reinterpret_cast<void *>(d_vertices), triVerts.data(),
               triVerts.size() * sizeof(float3_t), cudaMemcpyHostToDevice);

    OptixBuildInput bi = {};
    bi.type = OPTIX_BUILD_INPUT_TYPE_TRIANGLES;
    bi.triangleArray.vertexFormat = OPTIX_VERTEX_FORMAT_FLOAT3;
    bi.triangleArray.vertexStrideInBytes = sizeof(float3_t);
    bi.triangleArray.numVertices = (unsigned)triVerts.size();
    bi.triangleArray.vertexBuffers = &d_vertices;
    unsigned int flags[1] = {OPTIX_GEOMETRY_FLAG_NONE};
    bi.triangleArray.flags = flags;
    bi.triangleArray.numSbtRecords = 1;

    OptixAccelBuildOptions ao = {};
    ao.buildFlags =
        OPTIX_BUILD_FLAG_ALLOW_COMPACTION | OPTIX_BUILD_FLAG_PREFER_FAST_TRACE;
    ao.operation = OPTIX_BUILD_OPERATION_BUILD;
    OptixAccelBufferSizes bs;
    optixAccelComputeMemoryUsage(optixCtx, &ao, &bi, 1, &bs);
    CUdeviceptr d_tmp, d_gas;
    cudaMalloc(reinterpret_cast<void **>(&d_tmp), bs.tempSizeInBytes);
    cudaMalloc(reinterpret_cast<void **>(&d_gas), bs.outputSizeInBytes);
    OptixTraversableHandle gasHandle = 0;

    OptixAccelEmitDesc emitDesc;
    emitDesc.type = OPTIX_PROPERTY_TYPE_AABBS;
    CUdeviceptr d_aabb;
    cudaMalloc((void **)&d_aabb, sizeof(OptixAabb));
    emitDesc.result = d_aabb;

    OptixResult accelRes =
        optixAccelBuild(optixCtx, 0, &ao, &bi, 1, d_tmp, bs.tempSizeInBytes,
                        d_gas, bs.outputSizeInBytes, &gasHandle, &emitDesc, 1);

    OptixAabb aabb;
    cudaMemcpy(&aabb, (void *)d_aabb, sizeof(OptixAabb),
               cudaMemcpyDeviceToHost);
    cudaFree((void *)d_aabb);
    std::cout << "  BVH AABB: (" << aabb.minX << "," << aabb.minY << ","
              << aabb.minZ << ") to (" << aabb.maxX << "," << aabb.maxY << ","
              << aabb.maxZ << ")\n";

    cudaFree(reinterpret_cast<void *>(d_tmp));
    std::cout << "  BVH: " << (bs.outputSizeInBytes / 1024)
              << " KB gasHandle=" << gasHandle
              << " accelBuild=" << (int)accelRes << "\n";

    // --- PTX Module ---
    OptixModuleCompileOptions mo = {};
    mo.maxRegisterCount = OPTIX_COMPILE_DEFAULT_MAX_REGISTER_COUNT;
    mo.optLevel = OPTIX_COMPILE_OPTIMIZATION_DEFAULT;
    mo.debugLevel = OPTIX_COMPILE_DEBUG_LEVEL_NONE;
    OptixPipelineCompileOptions po = {};
    po.traversableGraphFlags = OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_GAS;
    po.numPayloadValues = 2;
    po.numAttributeValues = 2;
    po.exceptionFlags = OPTIX_EXCEPTION_FLAG_NONE;
    po.pipelineLaunchParamsVariableName = "params";
    OptixModule mod = nullptr;
    char logBuf[2048];
    size_t logSz = sizeof(logBuf);
    optRes = optixModuleCreate(optixCtx, &mo, &po, OPTIX_KERNELS_PTX,
                               strlen(OPTIX_KERNELS_PTX), logBuf, &logSz, &mod);
    if (optRes != OPTIX_SUCCESS) {
      std::cout << "  ERROR: module (" << (int)optRes << ")\n";
      if (logSz > 1)
        std::cout << logBuf << "\n";
      goto phase5_done;
    }

    // --- Program Groups ---
    OptixProgramGroupOptions pgo = {};
    OptixProgramGroupDesc rgDesc = {};
    rgDesc.kind = OPTIX_PROGRAM_GROUP_KIND_RAYGEN;
    rgDesc.raygen.module = mod;
    rgDesc.raygen.entryFunctionName = "__raygen__lightmap";
    OptixProgramGroup rgPG;
    logSz = sizeof(logBuf);
    optixProgramGroupCreate(optixCtx, &rgDesc, 1, &pgo, logBuf, &logSz, &rgPG);

    // Bounce raygen program group
    OptixProgramGroupDesc bouncePGDesc = {};
    bouncePGDesc.kind = OPTIX_PROGRAM_GROUP_KIND_RAYGEN;
    bouncePGDesc.raygen.module = mod;
    bouncePGDesc.raygen.entryFunctionName = "__raygen__bounce";
    OptixProgramGroup bouncePG;
    logSz = sizeof(logBuf);
    optixProgramGroupCreate(optixCtx, &bouncePGDesc, 1, &pgo, logBuf, &logSz,
                            &bouncePG);

    OptixProgramGroupDesc msDesc = {};
    msDesc.kind = OPTIX_PROGRAM_GROUP_KIND_MISS;
    msDesc.miss.module = mod;
    msDesc.miss.entryFunctionName = "__miss__radiance";
    OptixProgramGroup msPG;
    logSz = sizeof(logBuf);
    optixProgramGroupCreate(optixCtx, &msDesc, 1, &pgo, logBuf, &logSz, &msPG);

    OptixProgramGroupDesc hgDesc = {};
    hgDesc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP;
    hgDesc.hitgroup.moduleCH = mod;
    hgDesc.hitgroup.entryFunctionNameCH = "__closesthit__radiance";
    OptixProgramGroup hgPG;
    logSz = sizeof(logBuf);
    optixProgramGroupCreate(optixCtx, &hgDesc, 1, &pgo, logBuf, &logSz, &hgPG);

    // --- Pipeline ---
    OptixPipelineLinkOptions lo = {};
    lo.maxTraceDepth = 1;
    OptixProgramGroup pgs[] = {rgPG, msPG, hgPG};
    OptixPipeline pipeline;
    logSz = sizeof(logBuf);
    optRes = optixPipelineCreate(optixCtx, &po, &lo, pgs, 3, logBuf, &logSz,
                                 &pipeline);
    if (optRes != OPTIX_SUCCESS) {
      std::cout << "  ERROR: pipeline (" << (int)optRes << ")\n";
      goto phase5_done;
    }
    std::cout << "  Pipeline ready\n";

    // --- SBT ---
    struct alignas(OPTIX_SBT_RECORD_ALIGNMENT) SbtRec {
      char header[OPTIX_SBT_RECORD_HEADER_SIZE];
    };
    SbtRec rgRec, msRec, hgRec;
    optixSbtRecordPackHeader(rgPG, &rgRec);
    optixSbtRecordPackHeader(msPG, &msRec);
    optixSbtRecordPackHeader(hgPG, &hgRec);
    CUdeviceptr d_rg, d_ms, d_hg;
    cudaMalloc(reinterpret_cast<void **>(&d_rg), sizeof(SbtRec));
    cudaMalloc(reinterpret_cast<void **>(&d_ms), sizeof(SbtRec));
    cudaMalloc(reinterpret_cast<void **>(&d_hg), sizeof(SbtRec));
    cudaMemcpy(reinterpret_cast<void *>(d_rg), &rgRec, sizeof(SbtRec),
               cudaMemcpyHostToDevice);
    cudaMemcpy(reinterpret_cast<void *>(d_ms), &msRec, sizeof(SbtRec),
               cudaMemcpyHostToDevice);
    cudaMemcpy(reinterpret_cast<void *>(d_hg), &hgRec, sizeof(SbtRec),
               cudaMemcpyHostToDevice);
    OptixShaderBindingTable sbt = {};
    sbt.raygenRecord = d_rg;
    sbt.missRecordBase = d_ms;
    sbt.missRecordStrideInBytes = sizeof(SbtRec);
    sbt.missRecordCount = 1;
    sbt.hitgroupRecordBase = d_hg;
    sbt.hitgroupRecordStrideInBytes = sizeof(SbtRec);
    sbt.hitgroupRecordCount = 1;

    // --- Parse light entities ---
    float sunDir[3] = {0, 0, 1}, sunCol[3] = {0, 0, 0};
    int hasSun = 0;
    std::vector<PointLight> gpuLightsVec;
    int numPtLights = 0;

    for (int ei = 0; ei < num_entities; ei++) {
      const char *cn = ValueForKey(&entities[ei], "classname");

      if (Q_stricmp(cn, "light_environment") == 0) {
        const char *ang = ValueForKey(&entities[ei], "angles");
        float pitch = 0, yaw = 0;
        if (ang[0])
          sscanf(ang, "%f %f", &pitch, &yaw);
        float pr = -pitch * 3.14159265f / 180.0f;
        float yr = yaw * 3.14159265f / 180.0f;
        sunDir[0] = cosf(pr) * cosf(yr);
        sunDir[1] = cosf(pr) * sinf(yr);
        sunDir[2] = sinf(pr);
        const char *lt = ValueForKey(&entities[ei], "_light");
        if (lt[0]) {
          double r, g, b, sc;
          int n = sscanf(lt, "%lf %lf %lf %lf", &r, &g, &b, &sc);
          if (n >= 3) {
            r = pow(r / 255.0, 2.2) * 255.0;
            g = pow(g / 255.0, 2.2) * 255.0;
            b = pow(b / 255.0, 2.2) * 255.0;
            if (n == 4 && sc > 0) {
              r *= sc / 255.0;
              g *= sc / 255.0;
              b *= sc / 255.0;
            }
            sunCol[0] = (float)r;
            sunCol[1] = (float)g;
            sunCol[2] = (float)b;
          }
        }
        hasSun = 1;
        std::cout << "  Sun: dir=(" << sunDir[0] << "," << sunDir[1] << ","
                  << sunDir[2] << ") col=(" << sunCol[0] << "," << sunCol[1]
                  << "," << sunCol[2] << ")\n";
      } else if (Q_stricmp(cn, "light") == 0 ||
                 Q_stricmp(cn, "light_spot") == 0) {
        if (numPtLights >= 1024)
          continue;
        const char *org = ValueForKey(&entities[ei], "origin");
        float ox = 0, oy = 0, oz = 0;
        if (org[0])
          sscanf(org, "%f %f %f", &ox, &oy, &oz);
        const char *lt = ValueForKey(&entities[ei], "_light");
        double r = 255, g = 255, b = 255, sc = 0;
        int n = 0;
        if (lt[0])
          n = sscanf(lt, "%lf %lf %lf %lf", &r, &g, &b, &sc);
        r = pow(r / 255.0, 2.2) * 255.0;
        if (n >= 3) {
          g = pow(g / 255.0, 2.2) * 255.0;
          b = pow(b / 255.0, 2.2) * 255.0;
        } else {
          g = r;
          b = r;
        }
        if (n == 4 && sc > 0) {
          r *= sc / 255.0;
          g *= sc / 255.0;
          b *= sc / 255.0;
        }
        float ca = (float)FloatForKey(&entities[ei], "_constant_attn");
        float la = (float)FloatForKey(&entities[ei], "_linear_attn");
        float qa = (float)FloatForKey(&entities[ei], "_quadratic_attn");
        if (ca < 1e-6f)
          ca = 0;
        if (la < 1e-6f)
          la = 0;
        if (qa < 1e-6f)
          qa = 0;
        if (ca < 1e-6f && la < 1e-6f && qa < 1e-6f)
          ca = 1.0f;
        float ratio = ca + 100.0f * la + 10000.0f * qa;
        if (ratio > 0) {
          r *= ratio;
          g *= ratio;
          b *= ratio;
        }
        gpuLightsVec.push_back(PointLight());
        PointLight &pl = gpuLightsVec.back();
        numPtLights++;
        pl.posX = ox;
        pl.posY = oy;
        pl.posZ = oz;
        pl.colR = (float)r;
        pl.colG = (float)g;
        pl.colB = (float)b;
        pl.constAttn = ca;
        pl.linearAttn = la;
        pl.quadAttn = qa;
        std::cout << "  Light[" << (numPtLights - 1) << "]: pos=(" << ox << ","
                  << oy << "," << oz << ") col=(" << (float)r << "," << (float)g
                  << "," << (float)b << ") attn=(" << ca << "," << la << ","
                  << qa << ")\n";
      }
    }
    std::cout << "  Lights: " << hasSun << " sun, " << numPtLights
              << " point/spot\n";

    // --- Generate per-luxel samples across all faces ---
    // For each face, compute the lightmap grid and map each
    // luxel to a world-space position using texinfo
    // lightmapVecs + face plane.
    struct FaceLuxelInfo {
      int faceIdx;
      int luxelW, luxelH; // lightmap dimension
      int sampleOffset;   // index into the flat sample array
    };
    std::vector<float> sPos, sNrm;
    std::vector<FaceLuxelInfo> faceLuxels;
    int nSamples = 0;
    int skippedFaces = 0;

    for (int fi = 0; fi < numfaces; fi++) {
      dface_t &f = dfaces[fi];
      if (f.numedges < 3)
        continue;

      int lmW = f.m_LightmapTextureSizeInLuxels[0] + 1;
      int lmH = f.m_LightmapTextureSizeInLuxels[1] + 1;
      if (lmW <= 0 || lmH <= 0 || lmW > 512 || lmH > 512) {
        skippedFaces++;
        continue;
      }

      // texinfo lightmap vectors: s = dot(pos, vec_s) +
      // ofs_s
      texinfo_t &ti = texinfo[f.texinfo];
      float sv[3] = {ti.lightmapVecsLuxelsPerWorldUnits[0][0],
                     ti.lightmapVecsLuxelsPerWorldUnits[0][1],
                     ti.lightmapVecsLuxelsPerWorldUnits[0][2]};
      float so = ti.lightmapVecsLuxelsPerWorldUnits[0][3];
      float tv[3] = {ti.lightmapVecsLuxelsPerWorldUnits[1][0],
                     ti.lightmapVecsLuxelsPerWorldUnits[1][1],
                     ti.lightmapVecsLuxelsPerWorldUnits[1][2]};
      float to = ti.lightmapVecsLuxelsPerWorldUnits[1][3];

      // Face plane as 3rd equation
      dplane_t &pl = dplanes[f.planenum];
      float pn[3] = {pl.normal[0], pl.normal[1], pl.normal[2]};
      float pd = pl.dist;
      float fnx = pn[0], fny = pn[1], fnz = pn[2];
      // NOTE: Do NOT flip based on f.side. The planenum already
      // references the outward-facing plane for this face.
      // Flipping produces black walls (negative NdotL).

      // Build 3x3 matrix: rows = [sv, tv, pn]
      // Solve: [sv] [x]   [s - so]
      //        [tv] [y] = [t - to]
      //        [pn] [z]   [pd    ]
      // Using Cramer's rule for 3x3 inversion
      float a[3][3] = {
          {sv[0], sv[1], sv[2]}, {tv[0], tv[1], tv[2]}, {pn[0], pn[1], pn[2]}};
      float det = a[0][0] * (a[1][1] * a[2][2] - a[1][2] * a[2][1]) -
                  a[0][1] * (a[1][0] * a[2][2] - a[1][2] * a[2][0]) +
                  a[0][2] * (a[1][0] * a[2][1] - a[1][1] * a[2][0]);
      if (fabsf(det) < 1e-10f) {
        skippedFaces++;
        continue;
      }

      // Compute inverse matrix (column-major for
      // convenience)
      float invDet = 1.0f / det;
      float inv[3][3];
      inv[0][0] = (a[1][1] * a[2][2] - a[1][2] * a[2][1]) * invDet;
      inv[0][1] = (a[0][2] * a[2][1] - a[0][1] * a[2][2]) * invDet;
      inv[0][2] = (a[0][1] * a[1][2] - a[0][2] * a[1][1]) * invDet;
      inv[1][0] = (a[1][2] * a[2][0] - a[1][0] * a[2][2]) * invDet;
      inv[1][1] = (a[0][0] * a[2][2] - a[0][2] * a[2][0]) * invDet;
      inv[1][2] = (a[0][2] * a[1][0] - a[0][0] * a[1][2]) * invDet;
      inv[2][0] = (a[1][0] * a[2][1] - a[1][1] * a[2][0]) * invDet;
      inv[2][1] = (a[0][1] * a[2][0] - a[0][0] * a[2][1]) * invDet;
      inv[2][2] = (a[0][0] * a[1][1] - a[0][1] * a[1][0]) * invDet;

      FaceLuxelInfo fli;
      fli.faceIdx = fi;
      fli.luxelW = lmW;
      fli.luxelH = lmH;
      fli.sampleOffset = nSamples;
      faceLuxels.push_back(fli);

      for (int lt = 0; lt < lmH; lt++) {
        for (int ls = 0; ls < lmW; ls++) {
          float sCoord = (float)(ls + f.m_LightmapTextureMinsInLuxels[0]) - so;
          float tCoord = (float)(lt + f.m_LightmapTextureMinsInLuxels[1]) - to;
          // rhs = [sCoord, tCoord, pd]
          float wx = inv[0][0] * sCoord + inv[0][1] * tCoord + inv[0][2] * pd;
          float wy = inv[1][0] * sCoord + inv[1][1] * tCoord + inv[1][2] * pd;
          float wz = inv[2][0] * sCoord + inv[2][1] * tCoord + inv[2][2] * pd;

          sPos.push_back(wx);
          sPos.push_back(wy);
          sPos.push_back(wz);
          sNrm.push_back(fnx);
          sNrm.push_back(fny);
          sNrm.push_back(fnz);
          nSamples++;
        }
      }
    }
    std::cout << "  Luxel samples: " << nSamples << " across "
              << faceLuxels.size() << " faces (" << skippedFaces
              << " skipped)\n";
    if (nSamples > 0) {
      std::cout << "  Sample 0 pos: (" << sPos[0] << "," << sPos[1] << ","
                << sPos[2] << ") "
                << "normal: (" << sNrm[0] << "," << sNrm[1] << "," << sNrm[2]
                << ")\n";
    }

    // --- Upload + launch ---
    CUdeviceptr d_sp, d_sn, d_out, d_par;
    cudaMalloc(reinterpret_cast<void **>(&d_sp), nSamples * 3 * sizeof(float));
    cudaMalloc(reinterpret_cast<void **>(&d_sn), nSamples * 3 * sizeof(float));
    cudaMalloc(reinterpret_cast<void **>(&d_out), nSamples * 3 * sizeof(float));
    cudaMemcpy(reinterpret_cast<void *>(d_sp), sPos.data(),
               nSamples * 3 * sizeof(float), cudaMemcpyHostToDevice);
    cudaMemcpy(reinterpret_cast<void *>(d_sn), sNrm.data(),
               nSamples * 3 * sizeof(float), cudaMemcpyHostToDevice);
    cudaMemset(reinterpret_cast<void *>(d_out), 0,
               nSamples * 3 * sizeof(float));

    LaunchParams hp = {};
    hp.traversable = gasHandle;
    hp.outputBuffer = reinterpret_cast<float *>(d_out);
    hp.numSamples = nSamples;
    hp.sunDirX = sunDir[0];
    hp.sunDirY = sunDir[1];
    hp.sunDirZ = sunDir[2];
    hp.sunColorR = sunCol[0];
    hp.sunColorG = sunCol[1];
    hp.sunColorB = sunCol[2];
    hp.hasSun = hasSun;
    // Upload lights to device
    CUdeviceptr d_lights = 0;
    if (numPtLights > 0) {
      cudaMalloc(reinterpret_cast<void **>(&d_lights),
                 numPtLights * sizeof(PointLight));
      cudaMemcpy(reinterpret_cast<void *>(d_lights), gpuLightsVec.data(),
                 numPtLights * sizeof(PointLight), cudaMemcpyHostToDevice);
    }
    hp.lights = reinterpret_cast<PointLight *>(d_lights);
    hp.numLights = numPtLights;
    hp.samplePositions = reinterpret_cast<float *>(d_sp);
    hp.sampleNormals = reinterpret_cast<float *>(d_sn);
    hp.bouncePassIndex = -1; // direct lighting mode
    hp.numBounceRays = 0;
    hp.totalLuxels = nSamples;
    hp.triToFace = nullptr;
    hp.faceInfos = nullptr;
    hp.bounceLightIn = nullptr;

    cudaMalloc(reinterpret_cast<void **>(&d_par), sizeof(LaunchParams));
    cudaMemcpy(reinterpret_cast<void *>(d_par), &hp, sizeof(LaunchParams),
               cudaMemcpyHostToDevice);

    std::cout << "  Launching " << nSamples << " shadow rays...\n";
    optRes = optixLaunch(pipeline, 0, d_par, sizeof(LaunchParams), &sbt,
                         nSamples, 1, 1);
    cudaDeviceSynchronize();

    if (optRes != OPTIX_SUCCESS) {
      std::cout << "  ERROR: launch (" << (int)optRes << ")\n";
    } else {
      // Download GPU results
      std::vector<float> res(nSamples * 3);
      cudaMemcpy(res.data(), reinterpret_cast<void *>(d_out),
                 nSamples * 3 * sizeof(float), cudaMemcpyDeviceToHost);

      // --- Statistics ---
      int litLuxels = 0, shadLuxels = 0, backLuxels = 0;
      for (int i = 0; i < nSamples; i++) {
        float lum = res[i * 3] * 0.299f + res[i * 3 + 1] * 0.587f +
                    res[i * 3 + 2] * 0.114f;
        if (lum > 0.001f)
          litLuxels++;
        else {
          float nd = sNrm[i * 3] * sunDir[0] + sNrm[i * 3 + 1] * sunDir[1] +
                     sNrm[i * 3 + 2] * sunDir[2];
          if (nd <= 0)
            backLuxels++;
          else
            shadLuxels++;
        }
      }

      std::cout << "\n[ Phase 5: Results ]\n";
      std::cout << "  Total luxels: " << nSamples << "\n";
      std::cout << "  Lit:          " << litLuxels << "\n";
      std::cout << "  Shadowed:     " << shadLuxels << "\n";
      std::cout << "  Backfacing:   " << backLuxels << "\n";

      // ============================================================
      // Phase 5b: Bounce Lighting
      // ============================================================
      const int NUM_BOUNCES = 50;
      const int BOUNCE_RAYS = 512;

      std::cout << "\n[ Phase 5b: Bounce Lighting (" << NUM_BOUNCES
                << " bounces, " << BOUNCE_RAYS << " rays/luxel) ]\n";

      // Build GPUFaceInfo for all faces
      std::vector<GPUFaceInfo> faceInfoVec(numfaces);
      for (auto &fli : faceLuxels) {
        int fi = fli.faceIdx;
        dface_t &f = dfaces[fi];
        texinfo_t &ti = texinfo[f.texinfo];
        GPUFaceInfo &gfi = faceInfoVec[fi];
        for (int c = 0; c < 4; c++) {
          gfi.lmS[c] = ti.lightmapVecsLuxelsPerWorldUnits[0][c];
          gfi.lmT[c] = ti.lightmapVecsLuxelsPerWorldUnits[1][c];
        }
        gfi.lmMinsS = f.m_LightmapTextureMinsInLuxels[0];
        gfi.lmMinsT = f.m_LightmapTextureMinsInLuxels[1];
        gfi.lmW = fli.luxelW;
        gfi.lmH = fli.luxelH;
        gfi.luxelOffset = fli.sampleOffset;
        // Surface reflectivity from BSP texdata
        int texdataIdx = ti.texdata;
        if (texdataIdx >= 0 && texdataIdx < numtexdata) {
          gfi.reflR = dtexdata[texdataIdx].reflectivity[0];
          gfi.reflG = dtexdata[texdataIdx].reflectivity[1];
          gfi.reflB = dtexdata[texdataIdx].reflectivity[2];
        } else {
          gfi.reflR = gfi.reflG = gfi.reflB = 0.5f;
        }
        // Face normal (unflipped plane normal, matching
        // direct pass)
        dplane_t &pl = dplanes[f.planenum];
        gfi.normalX = pl.normal[0];
        gfi.normalY = pl.normal[1];
        gfi.normalZ = pl.normal[2];
      }
      // Diagnostic: check face info values
      {
        float maxRefl = 0;
        int validFaces = 0;
        for (auto &fli : faceLuxels) {
          GPUFaceInfo &gfi = faceInfoVec[fli.faceIdx];
          float r = gfi.reflR + gfi.reflG + gfi.reflB;
          if (r > maxRefl)
            maxRefl = r;
          if (gfi.lmW > 0 && gfi.lmH > 0)
            validFaces++;
        }
        std::cout << "  FaceInfo: " << validFaces
                  << " valid, maxRefl=" << maxRefl
                  << ", triToFace=" << triToFace.size() << "\n";
      }

      // Upload triToFace + faceInfos to GPU
      CUdeviceptr d_triToFace = 0, d_faceInfos = 0;
      cudaMalloc(reinterpret_cast<void **>(&d_triToFace),
                 triToFace.size() * sizeof(int));
      cudaMemcpy(reinterpret_cast<void *>(d_triToFace), triToFace.data(),
                 triToFace.size() * sizeof(int), cudaMemcpyHostToDevice);
      cudaMalloc(reinterpret_cast<void **>(&d_faceInfos),
                 numfaces * sizeof(GPUFaceInfo));
      cudaMemcpy(reinterpret_cast<void *>(d_faceInfos), faceInfoVec.data(),
                 numfaces * sizeof(GPUFaceInfo), cudaMemcpyHostToDevice);

      // Bounce ping-pong buffers
      CUdeviceptr d_bounceA = 0, d_bounceB = 0;
      cudaMalloc(reinterpret_cast<void **>(&d_bounceA),
                 nSamples * 3 * sizeof(float));
      cudaMalloc(reinterpret_cast<void **>(&d_bounceB),
                 nSamples * 3 * sizeof(float));
      // --- Energy-Conserving Firefly Mitigation Phase (Macro-Patch Simulation)
      // --- Legacy VRAD mitigates 1/d^2 singularities organically because it
      // transfers light between spatial macro-patches (e.g. 16x16 units avg),
      // naturally squashing sub-pixel hotspots (150,000+ luminance) into
      // manageable diffuse blocks. In Path Tracing, if we rely on pure uniform
      // stochastic sampling, rare hits on microscopic 150k hotspots cause
      // extreme variance (fireflies). By locally blurring the direct lightmap
      // before Bounce 1, we smear sub-pixel anomalies into uniform
      // energy-conserving patches, drastically reducing sampler variance while
      // perfectly conserving the total ambient radiosity pool.
      std::cout
          << "  Applying energy-conserving patch blur to direct light...\n";
      std::vector<float> resBlurred(res.begin(), res.end());
      const int BLUR_RADIUS = 2; // 5x5 blur
      for (int pass = 0; pass < 2;
           pass++) { // 2 passes approximates an energy-conserving Gaussian
        std::vector<float> tempBlur = resBlurred;
        for (auto &fli : faceLuxels) {
          int lmW = fli.luxelW;
          int lmH = fli.luxelH;
          for (int y = 0; y < lmH; y++) {
            for (int x = 0; x < lmW; x++) {
              float sumR = 0, sumG = 0, sumB = 0;
              int count = 0;
              for (int dy = -BLUR_RADIUS; dy <= BLUR_RADIUS; dy++) {
                for (int dx = -BLUR_RADIUS; dx <= BLUR_RADIUS; dx++) {
                  int nx = x + dx;
                  int ny = y + dy;
                  if (nx >= 0 && nx < lmW && ny >= 0 && ny < lmH) {
                    int nidx = fli.sampleOffset + (ny * lmW + nx);
                    sumR += tempBlur[nidx * 3 + 0];
                    sumG += tempBlur[nidx * 3 + 1];
                    sumB += tempBlur[nidx * 3 + 2];
                    count++;
                  }
                }
              }
              int idx = fli.sampleOffset + (y * lmW + x);
              resBlurred[idx * 3 + 0] = sumR / count;
              resBlurred[idx * 3 + 1] = sumG / count;
              resBlurred[idx * 3 + 2] = sumB / count;
            }
          }
        }
      }

      // Keep res[] as-is (raw direct light); we'll blur the FINAL result
      // after all bounces have been accumulated.
      // Seed bounceA with the blurred direct lighting results (clean input
      // for Monte Carlo bounce sampling to reduce firefly variance).
      cudaMemcpy(reinterpret_cast<void *>(d_bounceA), resBlurred.data(),
                 nSamples * 3 * sizeof(float), cudaMemcpyHostToDevice);

      // Verify seeding
      {
        std::vector<float> seedCheck(nSamples * 3);
        cudaMemcpy(seedCheck.data(), reinterpret_cast<void *>(d_bounceA),
                   nSamples * 3 * sizeof(float), cudaMemcpyDeviceToHost);
        float maxVal = 0;
        int nonzero = 0;
        for (int i = 0; i < nSamples * 3; i++) {
          if (seedCheck[i] > maxVal)
            maxVal = seedCheck[i];
          if (seedCheck[i] > 0.001f)
            nonzero++;
        }
        std::cout << "  Bounce seed: maxVal=" << maxVal
                  << " nonzero=" << nonzero << "/" << (nSamples * 3) << "\n";
      }

      for (int bounce = 0; bounce < NUM_BOUNCES; bounce++) {
        LaunchParams bhp = hp; // copy direct pass constants (gasHandle, etc.)
        bhp.bouncePassIndex = bounce;
        bhp.outputBuffer = reinterpret_cast<float *>(d_bounceB);
        bhp.bounceLightIn = reinterpret_cast<float *>(d_bounceA);
        bhp.triToFace = reinterpret_cast<int *>(d_triToFace);
        bhp.faceInfos = reinterpret_cast<GPUFaceInfo *>(d_faceInfos);
        bhp.numBounceRays = BOUNCE_RAYS;

        cudaMemcpy(reinterpret_cast<void *>(d_par), &bhp, sizeof(LaunchParams),
                   cudaMemcpyHostToDevice);

        std::cout << "  Bounce " << (bounce + 1) << "/" << NUM_BOUNCES
                  << ": launching " << nSamples << " x " << BOUNCE_RAYS
                  << " rays...\n";
        optRes = optixLaunch(pipeline, 0, d_par, sizeof(LaunchParams), &sbt,
                             nSamples, 1, 1);
        cudaError_t syncErr = cudaDeviceSynchronize();
        if (syncErr != cudaSuccess) {
          std::cout << "  ERROR sync: " << cudaGetErrorString(syncErr) << "\n";
        }

        if (optRes != OPTIX_SUCCESS) {
          std::cout << "  ERROR: bounce launch (" << (int)optRes << ")\n";
          break;
        }

        // Download bounce results and accumulate into res[]
        std::vector<float> bounceRes(nSamples * 3);
        cudaError_t cpyErr =
            cudaMemcpy(bounceRes.data(), reinterpret_cast<void *>(d_bounceB),
                       nSamples * 3 * sizeof(float), cudaMemcpyDeviceToHost);
        if (cpyErr != cudaSuccess) {
          std::cout << "  ERROR memcpy: " << cudaGetErrorString(cpyErr) << "\n";
        }

        double avgR = 0, avgG = 0, avgB = 0;
        for (int i = 0; i < nSamples; i++) {
          avgR += bounceRes[i * 3 + 0];
          avgG += bounceRes[i * 3 + 1];
          avgB += bounceRes[i * 3 + 2];
          // Accumulate into total result
          res[i * 3 + 0] += bounceRes[i * 3 + 0];
          res[i * 3 + 1] += bounceRes[i * 3 + 1];
          res[i * 3 + 2] += bounceRes[i * 3 + 2];
        }
        std::cout << "  Bounce " << (bounce + 1)
                  << " avgR=" << (avgR / nSamples)
                  << " avgG=" << (avgG / nSamples)
                  << " avgB=" << (avgB / nSamples) << "\n";

        std::cout << "  DIAG RAY 0: " << bounceRes[0] << "\n";

        // Swap: bounceB becomes input for next pass
        CUdeviceptr tmp = d_bounceA;
        d_bounceA = d_bounceB;
        d_bounceB = tmp;
      }
      cudaFree(reinterpret_cast<void *>(d_bounceA));
      cudaFree(reinterpret_cast<void *>(d_bounceB));
      cudaFree(reinterpret_cast<void *>(d_triToFace));
      cudaFree(reinterpret_cast<void *>(d_faceInfos));

      // ============================================================
      // Post-Accumulation OptiX AI Denoiser (per-face)
      // ============================================================
      std::cout << "  OptiX AI denoiser: initializing...\n";
      {
        // Find max face dimensions for denoiser setup
        unsigned int maxW = 0, maxH = 0;
        for (auto &fli : faceLuxels) {
          if ((unsigned)fli.luxelW > maxW)
            maxW = fli.luxelW;
          if ((unsigned)fli.luxelH > maxH)
            maxH = fli.luxelH;
        }

        // Create denoiser — AOV model, no guide layers
        OptixDenoiser denoiser = nullptr;
        OptixDenoiserOptions dnOpts = {};
        dnOpts.guideAlbedo = 0;
        dnOpts.guideNormal = 0;
        dnOpts.denoiseAlpha = OPTIX_DENOISER_ALPHA_MODE_COPY;
        OptixResult dnRes = optixDenoiserCreate(
            optixCtx, OPTIX_DENOISER_MODEL_KIND_AOV, &dnOpts, &denoiser);
        if (dnRes != OPTIX_SUCCESS) {
          std::cout << "  WARNING: denoiser create failed (" << (int)dnRes
                    << "), skipping denoise\n";
        } else {
          // Compute memory requirements
          OptixDenoiserSizes dnSizes = {};
          optixDenoiserComputeMemoryResources(denoiser, maxW, maxH, &dnSizes);

          CUdeviceptr d_dnState = 0, d_dnScratch = 0;
          cudaMalloc(reinterpret_cast<void **>(&d_dnState),
                     dnSizes.stateSizeInBytes);
          cudaMalloc(reinterpret_cast<void **>(&d_dnScratch),
                     dnSizes.withoutOverlapScratchSizeInBytes);

          // Setup denoiser
          optixDenoiserSetup(denoiser, 0, maxW, maxH, d_dnState,
                             dnSizes.stateSizeInBytes, d_dnScratch,
                             dnSizes.withoutOverlapScratchSizeInBytes);

          // Allocate GPU buffers for per-face input/output
          size_t maxPixels = (size_t)maxW * maxH;
          CUdeviceptr d_dnIn = 0, d_dnOut = 0, d_hdrIntensity = 0;
          cudaMalloc(reinterpret_cast<void **>(&d_dnIn),
                     maxPixels * 3 * sizeof(float));
          cudaMalloc(reinterpret_cast<void **>(&d_dnOut),
                     maxPixels * 3 * sizeof(float));
          cudaMalloc(reinterpret_cast<void **>(&d_hdrIntensity), sizeof(float));

          int dnFaces = 0, dnSkipped = 0;
          for (auto &fli : faceLuxels) {
            int lmW = fli.luxelW;
            int lmH = fli.luxelH;

            // Skip tiny faces — AI model needs reasonable dimensions
            if (lmW < 4 || lmH < 4) {
              dnSkipped++;
              continue;
            }

            size_t facePixels = (size_t)lmW * lmH;

            // Upload this face's lightmap data to GPU
            cudaMemcpy(reinterpret_cast<void *>(d_dnIn),
                       &res[fli.sampleOffset * 3],
                       facePixels * 3 * sizeof(float), cudaMemcpyHostToDevice);

            // Build input/output image descriptors
            OptixImage2D inputImg = {};
            inputImg.data = d_dnIn;
            inputImg.width = lmW;
            inputImg.height = lmH;
            inputImg.rowStrideInBytes = lmW * 3 * sizeof(float);
            inputImg.pixelStrideInBytes = 3 * sizeof(float);
            inputImg.format = OPTIX_PIXEL_FORMAT_FLOAT3;

            OptixImage2D outputImg = inputImg;
            outputImg.data = d_dnOut;

            // Compute HDR intensity for this face
            optixDenoiserComputeIntensity(
                denoiser, 0, &inputImg, d_hdrIntensity, d_dnScratch,
                dnSizes.withoutOverlapScratchSizeInBytes);

            // Setup guide layer (empty — no guides)
            OptixDenoiserGuideLayer guideLayer = {};

            // Setup denoiser layer
            OptixDenoiserLayer dnLayer = {};
            dnLayer.input = inputImg;
            dnLayer.output = outputImg;

            // Invoke denoiser
            OptixDenoiserParams dnParams = {};
            dnParams.hdrIntensity = d_hdrIntensity;
            dnRes = optixDenoiserInvoke(
                denoiser, 0, &dnParams, d_dnState, dnSizes.stateSizeInBytes,
                &guideLayer, &dnLayer, 1, 0, 0, d_dnScratch,
                dnSizes.withoutOverlapScratchSizeInBytes);

            if (dnRes == OPTIX_SUCCESS) {
              cudaDeviceSynchronize();
              // Download denoised result back to res[]
              cudaMemcpy(
                  &res[fli.sampleOffset * 3], reinterpret_cast<void *>(d_dnOut),
                  facePixels * 3 * sizeof(float), cudaMemcpyDeviceToHost);
              dnFaces++;
            } else {
              dnSkipped++;
            }
          }

          std::cout << "  Denoised " << dnFaces << " faces, skipped "
                    << dnSkipped << " (< 4x4)\n";

          // Cleanup
          cudaFree(reinterpret_cast<void *>(d_dnIn));
          cudaFree(reinterpret_cast<void *>(d_dnOut));
          cudaFree(reinterpret_cast<void *>(d_hdrIntensity));
          cudaFree(reinterpret_cast<void *>(d_dnState));
          cudaFree(reinterpret_cast<void *>(d_dnScratch));
          optixDenoiserDestroy(denoiser);
        }
      }

      // ============================================================
      // Cross-Face Edge Stitching
      // ============================================================
      // Eliminate visible seams between adjacent BSP faces by
      // averaging luxels along shared edges. Each BSP edge is used
      // by exactly 2 faces (internal) or 1 face (boundary).
      std::cout << "  Cross-face edge stitching...\n";
      if (1) // Re-enabled: per-face denoiser creates seams at face boundaries
      {
        // Build face index -> faceLuxels index lookup
        std::vector<int> faceToFLI(numfaces, -1);
        for (int i = 0; i < (int)faceLuxels.size(); i++) {
          faceToFLI[faceLuxels[i].faceIdx] = i;
        }

        // Build edge -> face map from BSP surfedges
        // edgeFaces[edgeIdx] = {faceA, faceB} (-1 if unused)
        std::vector<std::pair<int, int>> edgeFaces(numedges, {-1, -1});
        for (int fi = 0; fi < numfaces; fi++) {
          dface_t &f = dfaces[fi];
          for (int j = 0; j < f.numedges; j++) {
            int se = dsurfedges[f.firstedge + j];
            int edgeIdx = (se < 0) ? -se : se;
            if (edgeIdx >= numedges)
              continue;
            if (edgeFaces[edgeIdx].first == -1)
              edgeFaces[edgeIdx].first = fi;
            else if (edgeFaces[edgeIdx].second == -1)
              edgeFaces[edgeIdx].second = fi;
          }
        }

        // For each shared edge, blend corresponding edge luxels
        int edgesStitched = 0, luxelsBlended = 0;
        for (int edgeIdx = 0; edgeIdx < numedges; edgeIdx++) {
          int fA = edgeFaces[edgeIdx].first;
          int fB = edgeFaces[edgeIdx].second;
          if (fA < 0 || fB < 0)
            continue;
          int fliA = faceToFLI[fA];
          int fliB = faceToFLI[fB];
          if (fliA < 0 || fliB < 0)
            continue;

          FaceLuxelInfo &flA = faceLuxels[fliA];
          FaceLuxelInfo &flB = faceLuxels[fliB];

          // Skip edges connecting opposite-facing faces (e.g.,
          // inside vs outside of a brush). Only stitch coplanar
          // or smoothly-adjacent faces.
          dplane_t &plA = dplanes[dfaces[fA].planenum];
          dplane_t &plB = dplanes[dfaces[fB].planenum];
          float nAx = plA.normal[0], nAy = plA.normal[1], nAz = plA.normal[2];
          float nBx = plB.normal[0], nBy = plB.normal[1], nBz = plB.normal[2];
          // Flip normal if the face uses the back side of the plane
          if (dfaces[fA].side) {
            nAx = -nAx;
            nAy = -nAy;
            nAz = -nAz;
          }
          if (dfaces[fB].side) {
            nBx = -nBx;
            nBy = -nBy;
            nBz = -nBz;
          }
          float ndot = nAx * nBx + nAy * nBy + nAz * nBz;
          if (ndot < -0.01f)
            continue; // opposite-facing, skip

          // Edge world-space endpoints
          float v0x = dvertexes[dedges[edgeIdx].v[0]].point[0];
          float v0y = dvertexes[dedges[edgeIdx].v[0]].point[1];
          float v0z = dvertexes[dedges[edgeIdx].v[0]].point[2];
          float v1x = dvertexes[dedges[edgeIdx].v[1]].point[0];
          float v1y = dvertexes[dedges[edgeIdx].v[1]].point[1];
          float v1z = dvertexes[dedges[edgeIdx].v[1]].point[2];

          // Project into face A lightmap UV
          texinfo_t &tiA = texinfo[dfaces[fA].texinfo];
          float sA0 = tiA.lightmapVecsLuxelsPerWorldUnits[0][0] * v0x +
                      tiA.lightmapVecsLuxelsPerWorldUnits[0][1] * v0y +
                      tiA.lightmapVecsLuxelsPerWorldUnits[0][2] * v0z +
                      tiA.lightmapVecsLuxelsPerWorldUnits[0][3] -
                      dfaces[fA].m_LightmapTextureMinsInLuxels[0];
          float tA0 = tiA.lightmapVecsLuxelsPerWorldUnits[1][0] * v0x +
                      tiA.lightmapVecsLuxelsPerWorldUnits[1][1] * v0y +
                      tiA.lightmapVecsLuxelsPerWorldUnits[1][2] * v0z +
                      tiA.lightmapVecsLuxelsPerWorldUnits[1][3] -
                      dfaces[fA].m_LightmapTextureMinsInLuxels[1];
          float sA1 = tiA.lightmapVecsLuxelsPerWorldUnits[0][0] * v1x +
                      tiA.lightmapVecsLuxelsPerWorldUnits[0][1] * v1y +
                      tiA.lightmapVecsLuxelsPerWorldUnits[0][2] * v1z +
                      tiA.lightmapVecsLuxelsPerWorldUnits[0][3] -
                      dfaces[fA].m_LightmapTextureMinsInLuxels[0];
          float tA1 = tiA.lightmapVecsLuxelsPerWorldUnits[1][0] * v1x +
                      tiA.lightmapVecsLuxelsPerWorldUnits[1][1] * v1y +
                      tiA.lightmapVecsLuxelsPerWorldUnits[1][2] * v1z +
                      tiA.lightmapVecsLuxelsPerWorldUnits[1][3] -
                      dfaces[fA].m_LightmapTextureMinsInLuxels[1];

          // Project into face B lightmap UV
          texinfo_t &tiB = texinfo[dfaces[fB].texinfo];
          float sB0 = tiB.lightmapVecsLuxelsPerWorldUnits[0][0] * v0x +
                      tiB.lightmapVecsLuxelsPerWorldUnits[0][1] * v0y +
                      tiB.lightmapVecsLuxelsPerWorldUnits[0][2] * v0z +
                      tiB.lightmapVecsLuxelsPerWorldUnits[0][3] -
                      dfaces[fB].m_LightmapTextureMinsInLuxels[0];
          float tB0 = tiB.lightmapVecsLuxelsPerWorldUnits[1][0] * v0x +
                      tiB.lightmapVecsLuxelsPerWorldUnits[1][1] * v0y +
                      tiB.lightmapVecsLuxelsPerWorldUnits[1][2] * v0z +
                      tiB.lightmapVecsLuxelsPerWorldUnits[1][3] -
                      dfaces[fB].m_LightmapTextureMinsInLuxels[1];
          float sB1 = tiB.lightmapVecsLuxelsPerWorldUnits[0][0] * v1x +
                      tiB.lightmapVecsLuxelsPerWorldUnits[0][1] * v1y +
                      tiB.lightmapVecsLuxelsPerWorldUnits[0][2] * v1z +
                      tiB.lightmapVecsLuxelsPerWorldUnits[0][3] -
                      dfaces[fB].m_LightmapTextureMinsInLuxels[0];
          float tB1 = tiB.lightmapVecsLuxelsPerWorldUnits[1][0] * v1x +
                      tiB.lightmapVecsLuxelsPerWorldUnits[1][1] * v1y +
                      tiB.lightmapVecsLuxelsPerWorldUnits[1][2] * v1z +
                      tiB.lightmapVecsLuxelsPerWorldUnits[1][3] -
                      dfaces[fB].m_LightmapTextureMinsInLuxels[1];

          // Walk edge in both UV spaces simultaneously
          float lenA =
              sqrtf((sA1 - sA0) * (sA1 - sA0) + (tA1 - tA0) * (tA1 - tA0));
          float lenB =
              sqrtf((sB1 - sB0) * (sB1 - sB0) + (tB1 - tB0) * (tB1 - tB0));
          int steps = (int)(fmaxf(lenA, lenB) + 1.0f);
          if (steps < 1)
            steps = 1;
          if (steps > 1024)
            steps = 1024;

          bool didStitch = false;
          for (int step = 0; step <= steps; step++) {
            float param = (steps > 0) ? (float)step / (float)steps : 0.0f;

            int ixA = (int)(sA0 + param * (sA1 - sA0) + 0.5f);
            int iyA = (int)(tA0 + param * (tA1 - tA0) + 0.5f);
            int ixB = (int)(sB0 + param * (sB1 - sB0) + 0.5f);
            int iyB = (int)(tB0 + param * (tB1 - tB0) + 0.5f);

            if (ixA < 0 || ixA >= flA.luxelW || iyA < 0 || iyA >= flA.luxelH)
              continue;
            if (ixB < 0 || ixB >= flB.luxelW || iyB < 0 || iyB >= flB.luxelH)
              continue;

            int idxA = flA.sampleOffset + (iyA * flA.luxelW + ixA);
            int idxB = flB.sampleOffset + (iyB * flB.luxelW + ixB);

            // Bounds check against res buffer
            if (idxA * 3 + 2 >= (int)res.size() ||
                idxB * 3 + 2 >= (int)res.size())
              continue;

            // 50/50 blend
            float avgR = (res[idxA * 3] + res[idxB * 3]) * 0.5f;
            float avgG = (res[idxA * 3 + 1] + res[idxB * 3 + 1]) * 0.5f;
            float avgB = (res[idxA * 3 + 2] + res[idxB * 3 + 2]) * 0.5f;
            res[idxA * 3] = avgR;
            res[idxA * 3 + 1] = avgG;
            res[idxA * 3 + 2] = avgB;
            res[idxB * 3] = avgR;
            res[idxB * 3 + 1] = avgG;
            res[idxB * 3 + 2] = avgB;
            luxelsBlended++;
            didStitch = true;
          }
          if (didStitch)
            edgesStitched++;
        }
        std::cout << "  Stitched " << edgesStitched << " edges, "
                  << luxelsBlended << " luxels blended\n";
      }

      // --- Write lightmap data back into BSP ---
      // Clear lightofs for ALL faces first to avoid stale
      // pointers
      for (int fi = 0; fi < numfaces; fi++) {
        dfaces[fi].lightofs = -1;
      }
      // Compute total lightmap data size and set face
      // lightofs (matches legacy PrecompLightmapOffsets format:
      //   lightofs points to the LUXEL data, avgColor is stored
      //   just before lightofs at [lightofs - 4*numStyles])
      int lightDataSize = 0;
      for (auto &fli : faceLuxels) {
        dface_t &f = dfaces[fli.faceIdx];

        // 1 light style (style 0 = normal)
        f.styles[0] = 0;
        for (int s = 1; s < MAXLIGHTMAPS; s++) {
          f.styles[s] = 255;
        }
        // avgColor (1 x ColorRGBExp32 = 4 bytes, stored before lightofs)
        lightDataSize += 4;
        // lightofs points to the luxel data (past avgColor)
        f.lightofs = lightDataSize;
        lightDataSize += fli.luxelW * fli.luxelH * (int)sizeof(ColorRGBExp32);
      }

      std::cout << "  faceLuxels: " << faceLuxels.size()
                << ", lightDataSize: " << lightDataSize << "\n";

      // Allocate and fill the lightmap lump
      pdlightdata->SetSize(lightDataSize);
      memset(pdlightdata->Base(), 0, lightDataSize);

      int facesWritten = 0;
      for (auto &fli : faceLuxels) {
        dface_t &f = dfaces[fli.faceIdx];
        if (f.lightofs <= 0)
          continue;

        int nLuxels = fli.luxelW * fli.luxelH;

        // Compute average color for this face
        Vector avgCol(0, 0, 0);
        for (int i = 0; i < nLuxels; i++) {
          int si = fli.sampleOffset + i;
          avgCol.x += res[si * 3 + 0];
          avgCol.y += res[si * 3 + 1];
          avgCol.z += res[si * 3 + 2];
        }
        if (nLuxels > 0) {
          avgCol /= (float)nLuxels;
        }

        // Write avgColor at lightofs - 4 (before luxel data)
        ColorRGBExp32 *pAvg =
            (ColorRGBExp32 *)&((*pdlightdata)[f.lightofs - 4]);
        VectorToColorRGBExp32(avgCol, *pAvg);

        // Write per-luxel ColorRGBExp32 data at lightofs
        ColorRGBExp32 *pOut = (ColorRGBExp32 *)&((*pdlightdata)[f.lightofs]);
        for (int i = 0; i < nLuxels; i++) {
          int si = fli.sampleOffset + i;
          Vector col(res[si * 3], res[si * 3 + 1], res[si * 3 + 2]);
          VectorToColorRGBExp32(col, pOut[i]);
        }
        facesWritten++;
      }

      std::cout << "  Faces lit:    " << facesWritten << "\n";
      std::cout << "  LM data:     " << (lightDataSize / 1024) << " KB\n";

      // -------------------------------------------------------------
      // WORKAROUND: The Source engine assumes a map is unlit (fullbright)
      // if it has no worldlights or ambient lighting lumps. Since Nextgen
      // doesn't compute these yet, we emit dummy lumps so the engine
      // loads our lightmaps correctly.
      // -------------------------------------------------------------
      extern int numworldlightsLDR;
      extern dworldlight_t dworldlightsLDR[MAX_MAP_WORLDLIGHTS];
      if (numworldlightsLDR == 0) {
        numworldlightsLDR = 1;
        memset(&dworldlightsLDR[0], 0, sizeof(dworldlight_t));
      }

      extern CUtlVector<dleafambientlighting_t> g_LeafAmbientLightingLDR;
      if (g_LeafAmbientLightingLDR.Count() == 0 && numleafs > 0) {
        g_LeafAmbientLightingLDR.SetSize(numleafs);
        memset(g_LeafAmbientLightingLDR.Base(), 0,
               numleafs * sizeof(dleafambientlighting_t));
      }

      extern CUtlVector<dleafambientindex_t> g_LeafAmbientIndexLDR;
      if (g_LeafAmbientIndexLDR.Count() == 0 && numleafs > 0) {
        g_LeafAmbientIndexLDR.SetSize(numleafs);
        for (int i = 0; i < numleafs; i++) {
          g_LeafAmbientIndexLDR[i].ambientSampleCount = 1;
          g_LeafAmbientIndexLDR[i].firstAmbientSample = i;
        }
      }

      // Write the BSP file back
      WriteBSPFile(sourcePath);
      std::cout << "  BSP written: " << sourcePath << "\n";
    }

    // Cleanup
    cudaFree(reinterpret_cast<void *>(d_par));
    cudaFree(reinterpret_cast<void *>(d_out));
    cudaFree(reinterpret_cast<void *>(d_sp));
    cudaFree(reinterpret_cast<void *>(d_sn));
    cudaFree(reinterpret_cast<void *>(d_rg));
    cudaFree(reinterpret_cast<void *>(d_ms));
    cudaFree(reinterpret_cast<void *>(d_hg));
    optixPipelineDestroy(pipeline);
    optixProgramGroupDestroy(rgPG);
    optixProgramGroupDestroy(msPG);
    optixProgramGroupDestroy(hgPG);
    optixModuleDestroy(mod);
    cudaFree(reinterpret_cast<void *>(d_gas));
    cudaFree(reinterpret_cast<void *>(d_vertices));
    optixDeviceContextDestroy(optixCtx);
    cudaDeviceReset();
  }
phase5_done:

  // UnparseEntities();
  // CloseBSPFile();
  std::cout << "\nComplete.\n";
  return 0;
}
